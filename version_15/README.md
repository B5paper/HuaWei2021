# README

版本变动：

1. 清空了没必要的代码。


学习到的知识：

1. 因为 map, unordered_map 等，在使用 [] 时，会自动创建键值对，所以在使用时应小心再小心。最好先用 find() 查一下是否存在。

2. 数据结构非常重要。单个数据结构 map，set，vector 等都很简单，好理解。但是它们的组合，以及它们存放的内容，会有多种效果，千变万化。在选择数据结构之前，要想好自己是需要查找功能，还是需要排序和查找，还是需要删除和添加，还是只需要遍历就好。键、值是否唯一，是否需要自动创建数据结构，还是只用 pair 就好，这些也很重要。

3. 如果某些变量或对象从程序开始到结束一直都存在，那么可以考虑把它设置为全局对象，避免函数参数太多，传来传去很麻烦。

4. 不要光想着代码和思路的优美，不要对付假想的问题。要实际分析数据，提出问题，做出假设，实施方案，最后检查假设的正确性。这样才是解决实际问题的思路。

5. 维护状态查询表时，要格外小心，隔几行代码就检查一下状态表的正确性。

6. `set`是靠`a < b`和`a > b`来判断两个元素是否相等的，因此如果我们自定义比较方法，即使两个元素的实际值不一样，但在我们的比较函数中得出两个元素一样的结论，`set`仍然会删除一个元素。或许可以用`multiset`解决这个问题，但是它需要查找特定元素，很慢很慢。

7. `emplace()`无法做类型检查，只有在编译时才能发现错误。`insert()`可以做类型检查。

8. `set()`中可以插入`pair`，默认按`first`的大小排序。

9. `multiset`加嵌套的`pair`是个神奇的组合，可以解决很多问题。对于不需要按键查找，只需要插入和删除的情况很适用。

10. 如果对一个容器又是删除，又是添加，比如修改一个`set`中的元素，但是`set`中的元素都是`const`类型，所以只能先删除，再添加，那么最好不要在一个循环中完成，而是创建一个`set`的 copy，然后把`set`清空，最后根据 copy，选择性地往`set`中添加内容。

11. 迭代器失效的问题。在容器中删除一个元素时，迭代器会失效。如果是`for`循环，解决办法是这样：

    ```c++
    set<int> s({4, 2, 3, 5, 1});

    for (auto &iter = s.begin(); iter != s.end(); )
    {
        if (condition)  // need delete an element
            del(iter++);  // 传入一个迭代器的副本，然后让本迭代器递增
        else
            ++iter;
    }
    ```

    在这种方法中，失效的是迭代器的副本，而本迭代器不会失效。

    一些`erase()`函数会返回下一个有效的迭代器：

    ```c++
    set<int> s({4, 2, 3, 5, 1});

    auto iter = s.begin();
    while (iter != s.end())
    {
        if (*iter % 2 == 0)
            iter = s.erase(iter);
        else
            ++iter;
    }
    ```

    可惜这两种方法都只适用于只删不增的操作。需要注意的是，有时迭代器失效并不是发生在本函数中，而是发生在本函数调用的其它函数中，这种隐蔽的错误很难察觉。

    如果我们既想删，又想增，那么最好构建一个容器的副本，对副本进行删除迭代，将原容器清空后，进行插入操作。

12. 有关映射的问题。比如我想将一个容器中的元素`{3, 5, 8, 4}`映射为`{5, 8, 4, 3}`，这个操作不能在一个循环中完成，因为有可能出现循环映射的情况。将 3 映射为 5 后，变成`{5, 5, 8, 4}`，接下来再将 5 映射为 8：`{8, 8, 8, 4}`，这样就出错了。正确的实现有两种方法，要么是创建一个空容器副本，然后按映射关系依次填入；要么先在一个循环里将需要映射的旧元素删除，然后再在另一个循环里将需要映射的新元素写入。

13. range-for 隐藏的迭代器失效更危险，因为没法手动`iter++`。

14. c++ 不能保证 lower bound 一定比 upper bound 小。所以还需要自己手动比较一下值。upper bound 是可以取到的！

15. 如果在 range-for，或 for 循环的头部出现 Rb tree 之类的 Segment fault 报错，基本是因为迭代器失效了，即容器中的元素有更改。

16. 匿名对象不能作为实参传递给接收引用的函数。